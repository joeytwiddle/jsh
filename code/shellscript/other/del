#!/bin/sh

## TODO: doesn't work well under chroot (cannot determine which partition the file is on).

## Deletes a file or files in a recoverable way (by moving them to a "RECLAIM" directory).
## If reclaimspace is setup (in cron), it will remove some of the "deleted" files when more disk space it needed.
## WARNING: This setup /can/ cause problems if you write large files to disk very quickly, and cron isn't called in time to reclaim the space necessary to finish writing the file.  Easily solved by deleting files from RECLAIM directory when you know you need space now/soon.  (Or you could call "reclaimspace 1000000" to ensure ~1Gig is reclaimed).

# jsh-ext-depends-ignore: from file cvs
# jsh-ext-depends: sed basename dirname realpath
# jsh-depends-ignore: reclaimspace
# jsh-depends: cursebold cursegreen cursered cursenorm realpath error wheremounted

## TODO: to make it more like windows recycle dir, we should rm a file if it is deleted from /RECLAIM or $JPATH/trash
## TODO: check for reclaimspace in crontab or otherwise, and warn if not present!
## BUG: doesn't work in chroot without bound mounts because df only reports /.

## TODO: overlapping problems with different users leaving non-writeable directories
## I guess writeability to dirs is not absolutely neccessary, since current deleting user can change filename with '_'s.
## But if all desired subdirs are unwireable, it may need to add '_' to the toplevel dir rather than the filename.

DOCVS=
if [ "$1" = "-cvs" ]
then DOCVS=true; shift
fi

if [ ! "$1" ] || [ "$1" = --help ]
then
	echo 'del [-cvs] <file>...'
	echo '  will move each <file> to the first writeable directory out of:'
	echo '    /RECLAIM on same partition (see reclaimspace), $TRASHDIR, $JPATH/trash,'
	echo '    $HOME/.trash, or /tmp/$USER-trash'
	echo '  The option -cvs also runs "cvs remove" on each file.'
	echo
	echo '  del can/should be a lossy history manager.  ;)'
	exit 1
fi

ALLOK=0

for FILE
do

	if [ -f "$FILE" ] || [ -d "$FILE" ]
	then

		MOUNTPNT=`wheremounted "$FILE"`
		PARENTDIR=`dirname "\`realpath \"$FILE\"\`"`

		## Work out where to move the file to.
		for TRASHDIR in "$MOUNTPNT/RECLAIM" "$TRASHDIR" "$JPATH/trash" "$HOME/.trash" /tmp/$USER-trash NO_DIR_WRITEABLE
		do
			if [ "$TRASHDIR" ]
			then
				if [ -w "$TRASHDIR" ]
				then break
				# else echo "not writeable: $TRASHDIR" >&2
				fi
				## Create the directory if its parent is writeable:
				if [ -w "`dirname \"$TRASHDIR\"`" ]
				then
					mkdir "$TRASHDIR"
					# chmod ugo+w "$TRASHDIR" ## Not secure.  Shared RECLAIM dirs should be created by root.
					chmod go-rwx "$TRASHDIR" ## Secure.  Other users can create their own TRASHDIR!  TODO: could act differently if we are root.
					break
				# else echo "not writeable: `dirname \"$TRASHDIR\"`" >&2
				fi
			fi
		done

		if [ "$TRASHDIR" = NO_DIR_WRITEABLE ]
		then
			error "No suitable trash directory found.  Please export environment variable TRASHDIR."
			ALLOK=1
			break ## continue
		fi

		## If deleting to $MOUNTPNT/RECLAIM then move MOUNTPNT from parent dir to delete to (otherwise we delete to $MOUNTPNT/RECLAIM/$MOUNTPNT/...!)
		if [ "$TRASHDIR" = "$MOUNTPNT/RECLAIM" ]
		then TODELPARENTDIR=/`echo "$PARENTDIR" | sed "s+^$MOUNTPNT++"`
		else TODELPARENTDIR="$PARENTDIR"
		fi
		## TODO: refactor TRASHDIR out of DEST, so that _s can be added to start of $TODELPARENTDIR if no subdirs are writeable.
		DEST="$TRASHDIR/$TODELPARENTDIR"
		PRETTYDEST="$TRASHDIR$TODELPARENTDIR"

		# Create destination directory
		while [ -f "$DEST" ]
		do
			echo "$DEST is a file - using $DEST.dir"
			DEST="$DEST.dir"
		done
		mkdir -p "$DEST"
		# chmod ugo+w "$DEST" ## TODO: and all created parents!  (Use while ! parent loop to create them all?)
		if [ ! -d "$DEST" ]
		then
			error "del: problem creating destination directory: $DEST"
			error "del: not moved to trash: $FILE"
			# waitforkeypress
			# exit 1
			ALLOK=1
			break ## continue
		fi

		FILENAME=`basename "$FILE"`

		while [ -f "$DEST/$FILENAME" ] || [ -d "$DEST/$FILENAME" ]
		do
			FILENAME="$FILENAME"_
		done

		# Something used to go wrong if $FILENAME is a dir ending in "/"

		# Move it and report =)
		echo "$FILE "`cursegreen`"->"`cursenorm`" $PRETTYDEST/$FILENAME"
		mv -f "$FILE" "$DEST/$FILENAME"

		# Remove from CVS
		if [ $DOCVS ]
		then
			if [ -d "$PARENTDIR/CVS" ]
			then
				cvs remove $FILE > /dev/null 2>&1
				if [ "$?" = 0 ]
				then echo "Removed from CVS"
				else echo "`cursered;cursebold`Error with CVS`cursenorm`"
				fi
			fi
		fi

	else

		error "del: does not exist: $FILE"
		ALLOK=1
		# continue

	fi

done

exit $ALLOK

## The beautiful original:
# echo "mkdir -p $TRASHDIR/$PWD/"
# mkdir -p $TRASHDIR/$PWD/
# echo "mv -f $@ $TRASHDIR/$PWD/"
# mv -f $@ $TRASHDIR/$PWD/
