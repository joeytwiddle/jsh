#!/bin/sh

## TODO: might be nice to do a quick check to see if any processes have a handle on (or are opening) each file before we delete it.

## TODO: could integrate with new deldirs script

## TODO: doesn't work well under chroot (cannot determine which partition the file is on).

## BUG TODO: del really is rubbish, sometimes it can't move a file to trash or delete it because the disk is full!

## Deletes a file or files in a recoverable way (by moving them to a "RECLAIM" directory).
## If reclaimspace is setup (in cron), it will remove some of the "deleted" files when more disk space it needed.
## WARNING: This setup /can/ cause problems if you write large files to disk very quickly, and cron isn't called in time to reclaim the space necessary to finish writing the file.  Easily solved by deleting files from RECLAIM directory when you know you need space now/soon.  (Or you could call "reclaimspace 1000000" to ensure ~1Gig is reclaimed).

# jsh-ext-depends-ignore: from file cvs
# jsh-ext-depends: sed basename dirname realpath
# this-script-does-not-depend-on-jsh: reclaimspace
# jsh-depends: cursebold cursegreen cursered cursenorm realpath error wheremounted

## TODO: to make it more like windows recycle dir, we should rm a file if it is deleted from /RECLAIM or $JPATH/trash
## TODO: check for reclaimspace in crontab or otherwise, and warn if not present!
## BUG: doesn't work in chroot without bound mounts because df only reports /.

## TODO: overlapping problems with different users leaving non-writeable directories
## I guess writeability to dirs is not absolutely neccessary, since current deleting user can change filename with '_'s.
## But if all desired subdirs are unwireable, it may need to add '_' to the toplevel dir rather than the filename.

## Consider: In the unlikely event that you create a symlink to a dir, then del
##   the symlink, then create a dir there, populate it, and then delete some files
##   within it, they might be sent to the place the link is pointing to.  In other
##   words, when we are deleting, we should check that none of the dirs in the
##   destination path are symlinks.  If they are, the file might be saved outside
##   the RECLAIM tree, maybe even on a different partition.  :|

DOCVS=
if [ "$1" = "-cvs" ]
then DOCVS=true; shift
fi

if [ ! "$1" ] || [ "$1" = --help ]
then
	echo 'del [-cvs] <file>...'
	echo '  will move each <file> to the first writeable directory out of:'
	echo '    /RECLAIM on same partition (see reclaimspace), $TRASHDIR, $JPATH/trash,'
	echo '    $HOME/.trash, or /tmp/$USER-trash'
	echo '  The option -cvs also runs "cvs remove" on each file.'
	echo
	echo '  del can/should be a lossy history manager.  ;)'
	exit 1
fi

ALLOK=0

# . importshfn memo
# . importshfn rememo

try_del () {

		## If deleting to $MOUNTPNT/RECLAIM then move MOUNTPNT from parent dir to delete to (otherwise we delete to $MOUNTPNT/RECLAIM/$MOUNTPNT/...!)
		if [ "$TRASHDIR" = "$MOUNTPNT/RECLAIM" ]
		then TODELPARENTDIR=/`echo "$PARENTDIR" | sed "s+^$MOUNTPNT++"`
		else TODELPARENTDIR="$PARENTDIR"
		fi
		## TODO: refactor TRASHDIR out of DESTDIR, so that _s can be added to start of $TODELPARENTDIR if no subdirs are writeable.
		DESTDIR="$TRASHDIR/$TODELPARENTDIR"
		PRETTYDEST="$TRASHDIR$TODELPARENTDIR"

		# Create destination directory
		while [ -f "$DESTDIR" ] || [ -L "$DESTDIR" ]
		do
			echo "$DESTDIR is a file - using $DESTDIR.dir"
			DESTDIR="$DESTDIR.dir"
		done

		## Atm the del system doesn't actually remove any files, it relies on reclaimspace running in a cronjob.
		## This has sometimes proved to be ineffective in maintaining enough free space to keep the system running.
		## Therefore we shall perform reclaimspace here, before we delete a file.
		mkdir -p "$DESTDIR"
		reclaimspace "`wheremounted "$DESTDIR"`"
		## we do this before the mkdir, because it likes to rmdir, so may if we're unlucky remove the dir we made! :)
		## ah but damn wheremounted doesn't work if DESTDIR doesn't exist yet!

		mkdir -p "$DESTDIR"
		# chmod ugo+w "$DESTDIR" ## TODO: and all created parents!  (Use while ! parent loop to create them all?)
		if [ ! -d "$DESTDIR" ]
		then
			error "del: problem creating destination directory: $DESTDIR"
			error "del: not moved to trash: $FILE"
			# waitforkeypress
			# exit 1
			# ALLOK=1 ## another attempt might work ... :)
			break ## continue ## TODO CHECK: does this break work now that we are inside the try_del fn?
		fi

		FILENAME=`basename "$FILE"`

		while [ -f "$DESTDIR/$FILENAME" ] || [ -d "$DESTDIR/$FILENAME" ] || [ -L "$DESTDIR/$FILENAME" ]
		# do FILENAME="$FILENAME"_
		do FILENAME="$FILENAME"."`geekdate -fine`"."$$" ## even if geekdate fails, we will at least append with a '.'
		done ## this could infloop if the previous check failed

		# Something used to go wrong if $FILENAME is a dir ending in "/"
		# Has this stopped?

		# Move it and report =)
		echo "$FILE "`cursegreen`"->"`cursenorm`" $PRETTYDEST/$FILENAME"
		mv -f "$FILE" "$DESTDIR/$FILENAME" # || ALLOK=2
		RETURN="$?"

		# Remove from CVS
		if [ $DOCVS ]
		then
			if [ -d "$PARENTDIR/CVS" ]
			then
				cvs remove $FILE > /dev/null 2>&1
				if [ "$?" = 0 ]
				then echo "Removed from CVS"
				else echo "`cursered;cursebold`Error with CVS`cursenorm`"
				fi
			fi
		fi

		return $RETURN

}

for FILE
do

	if [ -f "$FILE" ] || [ -d "$FILE" ] || [ -L "$FILE" ]
	then

		## Efficiency attempt (appears to work if we import memo above, but should use a more efficient memo!)
		# X=`dirname "$FILE"`
		# MOUNTPNT=`memo wheremounted "$X/"`
		## TODO: does this really do what we want when $FILE is an existing symlink?
		# PARENTDIR=`dirname "\`realpath \"$FILE\"\`"`
		PARENTDIR=`realpath "\`dirname \"$FILE\"\`"`
		## NOTE sort-of BUG: if you delete a symlink, the symlink is deleted ok, but it doesn't go to the reclaim directory it is in; it goes to the reclaim directory the symlink's target is in.
		MOUNTPNT=`wheremounted "$PARENTDIR"`
		# Try this for speed: MOUNTPNT=`memo wheremounted "$PARENTDIR"`

		## TODO: make a memo.quickndirty (local to current shell env, i.e. data stored in variables?),
		##       and refactor out from here a getreclaimdirfordir <dir> function.

		## Work out where to move the file to.
		for TRASHDIR in "$MOUNTPNT/RECLAIM" "$TRASHDIR" "$JPATH/trash" "$HOME/.trash" /tmp/$USER-trash NO_DIR_WRITEABLE
		do
			if [ "$TRASHDIR" ]
			then
				if [ -w "$TRASHDIR" ]
				then try_del && break
				# else echo "not writeable: $TRASHDIR" >&2
				fi
				## Create the directory if its parent is writeable:
				if [ -w "`dirname \"$TRASHDIR\"`" ]
				then
					verbosely mkdir "$TRASHDIR"
					# chmod ugo+w "$TRASHDIR" ## Not secure.  Shared RECLAIM dirs should be created by root.
					chmod go-rwx "$TRASHDIR" ## Secure.  Other users can create their own TRASHDIR!  TODO: could act differently if we are root.
					# chmod go+rwx "$TRASHDIR" ## Insecure trashdir, but at least others can use it!
					## Only finish if we succeeded in creating a writeable trashdir:
					[ -w "$TRASHDIR" ] && try_del && break
				# else echo "not writeable: `dirname \"$TRASHDIR\"`" >&2
				fi
			fi
		done

		## Now we either left that for loop because try_del succeeded and we broke out, or we reached the end of the loop.
		if [ "$TRASHDIR" = NO_DIR_WRITEABLE ]
		then
			error "No suitable trash directory found.  Please export environment variable TRASHDIR."
			ALLOK=1
			break ## continue
		fi

	else

		error "del: does not exist: $FILE"
		ALLOK=1
		# continue

	fi

done

[ "$TRASHDIR" ] && dfh "$TRASHDIR" ## Your trashdir $TRASHDIR is size NNN meg.

exit $ALLOK

## The beautiful original:
# echo "mkdir -p $TRASHDIR/$PWD/"
# mkdir -p $TRASHDIR/$PWD/
# echo "mv -f $@ $TRASHDIR/$PWD/"
# mv -f $@ $TRASHDIR/$PWD/
