## Does not preserve order, which makes it a "set" function, whereas removeduplicatelinespo is the corresponding (slower) "list" fn.  Could rephrase / rename scripts to convey this concept.
# jsh-depends: bounce
# but there is a nice new version with extension po which does
# using sort...

# Apparently sed can do it like this: sed '$!N; /^\(.*\)\n\1$/!P; D'
# and there is also "uniq"

## TODO: at some point check whether sort's -u option might make removeduplicatelines or keepduplicatelines or something else faster...

## Also see: uniq(1)

if [ "$1" = "--help" ]
then
  # outputs the set of lines from stdin or <files>, sorted, with duplicates removed.
cat << !

removeduplicatelines [ -adj ] [ <files> ]

  reads from stdin or <files>, removes duplicate lines, and echos to stdout.

  BUT: it does not preserve the order of the stream; it sorts it.

  With the -adj option: does not sort the lines before processing.
    This can be used to save processing if the stream is already sorted.
    Otherwise, preserves line order, but only squeezes adjacent duplicates.

  Note: to preserve order but remove non-adjacent duplicates, use
        removeduplicatelinespo .

!
exit 1
fi

SORT="sort"
if [ "$1" = "-adj" ]
then SORT="cat"; shift
fi

Y="what would be a non-existent string, if such a string was possible"
cat "$@" |
$SORT |
while read X
do
  if [ ! "$X" = "$Y" ]
  then
      bounce "$X"
      Y="$X"
  fi
done
